#!/usr/bin/env python3
import argparse
import datetime
import os
import re

import torch
import torchmetrics

import npfl138
npfl138.require_version("2425.7.2")
from npfl138.datasets.morpho_dataset import MorphoDataset

parser = argparse.ArgumentParser()
# These arguments will be set appropriately by ReCodEx, even if you change them.
parser.add_argument("--batch_size", default=10, type=int, help="Batch size.")
parser.add_argument("--cle_dim", default=32, type=int, help="CLE embedding dimension.")
parser.add_argument("--epochs", default=5, type=int, help="Number of epochs.")
parser.add_argument("--max_sentences", default=None, type=int, help="Maximum number of sentences to load.")
parser.add_argument("--recodex", default=False, action="store_true", help="Evaluation in ReCodEx.")
parser.add_argument("--rnn", default="LSTM", choices=["LSTM", "GRU"], help="RNN layer type.")
parser.add_argument("--rnn_dim", default=64, type=int, help="RNN layer dimension.")
parser.add_argument("--seed", default=42, type=int, help="Random seed.")
parser.add_argument("--threads", default=1, type=int, help="Maximum number of threads to use.")
parser.add_argument("--we_dim", default=64, type=int, help="Word embedding dimension.")
parser.add_argument("--word_masking", default=0.0, type=float, help="Mask words with the given probability.")
# If you add more arguments, ReCodEx will keep them with your default values.


class Model(npfl138.TrainableModule):
    class MaskElements(torch.nn.Module):
        """A layer randomly masking elements with a given value."""
        def __init__(self, mask_probability, mask_value):
            super().__init__()
            self._mask_probability = mask_probability
            self._mask_value = mask_value

        def forward(self, inputs: torch.Tensor) -> torch.Tensor:
            # Only mask during training and when the mask probability is non-zero.
            if self.training and self._mask_probability:
                # TODO: Generate a mask tensor of `torch.float32`s of the same shape
                # as `inputs` using either `torch.rand` or `torch.rand_like`.
                # Then replace the inputs elements whose mask value is less than
                # `self._mask_probability` with the value of `self._mask_value`.
                mask = torch.rand_like(inputs, dtype=torch.float32) < self._mask_probability
                inputs = torch.where(mask, self._mask_value, inputs)
            return inputs

    def __init__(self, args: argparse.Namespace, train: MorphoDataset.Dataset) -> None:
        super().__init__()

        # Create all needed layers.
        # TODO: Create a word masking layer `self.MaskElements` with the given
        # `args.word_masking` probability and `MorphoDataset.UNK` as the masking value.
        self._word_masking = self.MaskElements(args.word_masking, MorphoDataset.UNK)

        # TODO: Create a `torch.nn.Embedding` layer for embedding the character ids
        # from `train.words.char_vocab` to dimensionality `args.cle_dim`.
        self._char_embedding = torch.nn.Embedding(len(train.words.char_vocab), args.cle_dim)

        # TODO: Create a bidirectional `torch.nn.GRU` layer processing the character
        # embeddings, producing output of dimensionality `args.cle_dim`.
        self._char_rnn = torch.nn.GRU(args.cle_dim, args.cle_dim, bidirectional=True, batch_first=False)

        # TODO(tagger_we): Create a `torch.nn.Embedding` layer, embedding the word ids
        # from `train.words.string_vocab` to dimensionality `args.we_dim`.
        self._word_embedding = torch.nn.Embedding(len(train.words.string_vocab), args.we_dim)

        # TODO: Create an RNN layer, either `torch.nn.LSTM` or `torch.nn.GRU` depending
        # on `args.rnn`. The layer should be bidirectional (`bidirectional=True`) with
        # dimensionality `args.rnn_dim`. During the model computation, the layer will
        # process the word embeddings generated by the `self._word_embedding` layer,
        # **now concatenated with the character-level embeddings**, and we will sum
        # the forward and backward outputs.
        rnn_class = torch.nn.LSTM if args.rnn == "LSTM" else torch.nn.GRU
        self._word_rnn = rnn_class(args.we_dim + 2 * args.cle_dim, args.rnn_dim, bidirectional=True, batch_first=False)

        # TODO(tagger_we): Create an output linear layer (`torch.nn.Linear`) processing the RNN output,
        # producing logits for tag prediction; `train.tags.string_vocab` is the tag vocabulary.
        self._output_layer = torch.nn.Linear(args.rnn_dim, len(train.tags.string_vocab))

    def forward(self, word_ids: torch.nn.utils.rnn.PackedSequence, unique_words: torch.nn.utils.rnn.PackedSequence,
                word_indices: torch.nn.utils.rnn.PackedSequence) -> torch.nn.utils.rnn.PackedSequence:
        # The input arguments are `PackedSequence`s. A `PackedSequence` allows us to:
        # - get the flattened data using `word_ids.data`; these are the data without
        #   padding elements, i.e., a 1D vector of shape `[sum_of_sentence_lengths]`;
        # - replace the data while keeping the sizes of the original sequences
        #   by calling `word_ids._replace(data=...)` and getting a new `PackedSequence`.
        # Therefore, depending on the context, we need to use either the flattened
        # data or the `PackedSequence` object.

        # TODO: Mask the input `word_ids` using the `self._word_masking` layer.
        # TODO: Embed the masked word IDs in `hidden` using the word embedding layer.
        # TODO: Embed the `unique_words` using the character embedding layer.
        # TODO: Pass the character embeddings through the character-level RNN,
        # obtaining fixed-size representation of every unique word in the batch.
        # The input to the RNN should be a `PackedSequence` with the same structure
        # as `unique_words`. Then, concatenate the states of the forward and backward
        # directions (in this order).
        # TODO: With `cle` being the character-level embeddings of the unique words
        # of shape `[num_unique_words, 2 * cle_dim]`, create the representation of the
        # (not necessary unique) sentence words by indexing the character-level
        # embeddings with the `word_indices`. The result should have an analogous structure
        # to word embeddings in `hidden`, just with a different dimensionality of the
        # embedding. You can use for example the `torch.nn.functional.embedding` function.
        # TODO: Concatenate the word embeddings with the character-level embeddings (in this order).
        # TODO(tagger_we.packed): Process the embedded words through the RNN layer, choosing the appropriate
        # output. The input to the RNN should be a `PackedSequence` with the same structure
        # as `word_ids` (i.e., the same sentence lengths).
        # TODO(tagger_we.packed): Sum the outputs of forward and backward directions.
        # TODO(tagger_we.packed): Pass the RNN output through the output layer.
        # TODO(tagger_we.packed): Finally, produce output predictions as a `PackedSequence`
        # with the same `PackedSequence` structure as `word_ids` (same sentence lengths).
        
        masked_data = self._word_masking(word_ids.data)
        masked_word_ids = word_ids._replace(data=masked_data)
        word_embeds = self._word_embedding(masked_word_ids.data)
        
        char_embeds = self._char_embedding(unique_words.data)
        char_embeds_packed = unique_words._replace(data=char_embeds)
        _, char_hidden = self._char_rnn(char_embeds_packed)
        cle = torch.cat([char_hidden[0], char_hidden[1]], dim=1)
        cle_for_words = cle[word_indices.data]
        
        combined = torch.cat([word_embeds, cle_for_words], dim=1)
        combined_packed = masked_word_ids._replace(data=combined)
        
        rnn_output, _ = self._word_rnn(combined_packed)
        summed_data = rnn_output.data[:, :self._word_rnn.hidden_size] + rnn_output.data[:, self._word_rnn.hidden_size:]
        summed_output = rnn_output._replace(data=summed_data)
        
        logits = self._output_layer(summed_output.data)
        return summed_output._replace(data=logits)

    def compute_loss(self, y_pred, y_true, *xs):
        # Because the `y_pred` and `y_true` are `PackedSequence` objects, we take
        # just their raw data and pass them to the loss function.
        return super().compute_loss(y_pred.data, y_true.data, *xs)

    def compute_metrics(self, y_pred, y_true, *xs):
        # Because the `y_pred` and `y_true` are `PackedSequence` objects, we take
        # just their raw data and pass them to the metric computation.
        return super().compute_metrics(y_pred.data, y_true.data, *xs)


class TrainableDataset(npfl138.TransformedDataset):
    def transform(self, example):
        # TODO(tagger_we): Construct a single example, each consisting of the following pair:
        # - a PyTorch tensor of integer ids of input words as input,
        # - a PyTorch tensor of integer tag ids as targets.
        # To create the ids, use `string_vocab` of `self.dataset.words` and `self.dataset.tags`.
        word_ids = torch.tensor(
            [self.dataset.words.string_vocab.indices([word])[0] for word in example["words"]], dtype=torch.long)
        tag_ids = torch.tensor(
            [self.dataset.tags.string_vocab.indices([tag])[0] for tag in example["tags"]], dtype=torch.long)
        # Note that compared to `tagger_we`, we also return the original
        # words in order to be able to compute the character-level embeddings.
        return word_ids, example["words"], tag_ids

    def collate(self, batch):
        # Construct a single batch, where `data` is a list of examples
        # generated by `transform`.
        word_ids, words, tag_ids = zip(*batch)
        # TODO(tagger_we.packed): Combine `word_ids` into a `PackedSequence` by calling
        # `torch.nn.utils.rnn.pack_sequence` with `enforce_sorted=False`.
        word_ids = torch.nn.utils.rnn.pack_sequence(word_ids, enforce_sorted=False)
        # TODO: Create required inputs for the character-level embeddings using
        # the provided `self.dataset.cle_batch_packed` function on `words`. The function
        # returns a pair of two PyTorch PackedSequences:
        # - `unique_words` containing each unique word as a sequence of character ids,
        # - `words_indices` containing for every word its index in `unique_words`.
        unique_words, words_indices = self.dataset.cle_batch_packed(words)
        # TODO(tagger_we): Process `tag_ids` analogously to `word_ids`.
        tag_ids = torch.nn.utils.rnn.pack_sequence(tag_ids, enforce_sorted=False)
        return (word_ids, unique_words, words_indices), tag_ids


def main(args: argparse.Namespace) -> dict[str, float]:
    # Set the random seed and the number of threads.
    npfl138.startup(args.seed, args.threads)
    npfl138.global_keras_initializers()

    # Create logdir name.
    args.logdir = os.path.join("logs", "{}-{}-{}".format(
        os.path.basename(globals().get("__file__", "notebook")),
        datetime.datetime.now().strftime("%Y-%m-%d_%H%M%S"),
        ",".join(("{}={}".format(re.sub("(.)[^_]*_?", r"\1", k), v) for k, v in sorted(vars(args).items())))
    ))

    # Load the data.
    morpho = MorphoDataset("czech_cac", max_sentences=args.max_sentences)

    # Prepare the data for training.
    train = TrainableDataset(morpho.train).dataloader(batch_size=args.batch_size, shuffle=True)
    dev = TrainableDataset(morpho.dev).dataloader(batch_size=args.batch_size)

    # Create the model and train.
    model = Model(args, morpho.train)

    model.configure(
        # TODO(tagger_we): Create the Adam optimizer.
        optimizer=torch.optim.Adam(model.parameters()),
        # TODO(tagger_we): Use the usual `torch.nn.CrossEntropyLoss` loss function.
        loss=torch.nn.CrossEntropyLoss(),
        # TODO(tagger_we): Create a multiclass `torchmetrics.Accuracy` metric, with `num_classes`
        # set to the number of unique tags.
        metrics={"accuracy": torchmetrics.Accuracy(task="multiclass", num_classes=len(morpho.train.tags.string_vocab))},
        logdir=args.logdir,
    )

    logs = model.fit(train, dev=dev, epochs=args.epochs)

    # Return development metrics for ReCodEx to validate.
    return {metric: value for metric, value in logs.items() if metric.startswith("dev_")}


if __name__ == "__main__":
    main_args = parser.parse_args([] if "__file__" not in globals() else None)
    main(main_args)
